package service.serviceImpl;

import data.Component;
import data.Dependency;
import data.ExternalReference;
import data.Hash;
import data.LicenseChoice;
import exceptions.SPDXBuilderException;
import logger.Logger;
import org.spdx.jacksonstore.MultiFormatStore;
import org.spdx.library.InvalidSPDXAnalysisException;
import org.spdx.library.ModelCopyManager;
import org.spdx.library.SpdxConstants;
import org.spdx.library.Version;
import org.spdx.library.model.Checksum;
import org.spdx.library.model.ExternalRef;
import org.spdx.library.model.ReferenceType;
import org.spdx.library.model.Relationship;
import org.spdx.library.model.SpdxCreatorInformation;
import org.spdx.library.model.SpdxDocument;
import org.spdx.library.model.SpdxElement;
import org.spdx.library.model.SpdxPackage;
import org.spdx.library.model.enumerations.ChecksumAlgorithm;
import org.spdx.library.model.enumerations.Purpose;
import org.spdx.library.model.enumerations.ReferenceCategory;
import org.spdx.library.model.enumerations.RelationshipType;
import org.spdx.library.model.license.LicenseInfoFactory;
import org.spdx.storage.simple.InMemSpdxStore;
import service.DocumentBuilder;
import util.Pair;

import java.io.File;
import java.io.FileOutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;


public class SPDXBuilder implements DocumentBuilder<Pair<SpdxDocument, Component>> {
    private static final Logger logger = Logger.of("SPDXBuilder");

    MultiFormatStore store;
    ModelCopyManager copyManager;
    String uri;
    SpdxDocument spdxDocument;
    Component root;

    HashMap<String, SpdxElement> buildSPDXElements = new HashMap<>();

    @Override
    public void buildDocument(Component root, String outputFileName) {
        var start = System.currentTimeMillis();
        logger.appendInfo("Creating SPDX for " + root.getQualifiedName() + "...");
        this.root = root;


        var outputFileDir = outputFileName.split("/", 2);
        if (outputFileDir.length > 1) {
            //create out dir if not exists
            File outDir = new File(outputFileDir[0]);
            if (!outDir.exists()) {
                if (!outDir.mkdirs()) {
                    logger.error("Could not create output folder for SPDX file: " + outDir.getAbsoluteFile());
                    throw new IllegalStateException();
                }
            }
        }

        // spdx json
        try (var out = new FileOutputStream(outputFileName + ".spdx.json")) {

            store = new MultiFormatStore(new InMemSpdxStore(), MultiFormatStore.Format.JSON_PRETTY, MultiFormatStore.Verbose.COMPACT);
            uri = "spdx-document/" + UUID.randomUUID();
            copyManager = new ModelCopyManager();
            spdxDocument = new SpdxDocument(store, uri, copyManager, true);
            buildDocument();

            // Save the SPDX document
            store.serialize(uri, out);

            logger.success(new File(outputFileName).getAbsolutePath() + ".spdx.json saved (" + (System.currentTimeMillis() - start) + "ms)");
        } catch (Exception e) {
            logger.error("Error building SPDX document" + e.getMessage());
            e.printStackTrace();
        }


    }

    private SpdxCreatorInformation buildCreationInfo() {
        try {
            var creationInfo = new SpdxCreatorInformation(store, uri, UUID.randomUUID().toString(), copyManager, true);
            creationInfo.setComment("Automatically generated SPDX Document");
            creationInfo.setCreated(new SimpleDateFormat(SpdxConstants.SPDX_DATE_FORMAT).format(new Date()));
            creationInfo.getCreators().add("Tool: Dependency-Crawler-1.0");
            creationInfo.getCreators().add("Organization: Technische UniversitÃ¤t Darmstadt");
            creationInfo.getCreators().add("Person: Henrik Bornemann");
//        creationInfo.setLicenseListVersion("3.0");
            return creationInfo;
        } catch (InvalidSPDXAnalysisException e) {
            logger.appendError("Error building CreationInfo" + e.getMessage());
        }
        return null;
    }

    private void buildDocument() {
        try {
            spdxDocument.setCreationInfo(buildCreationInfo());
            spdxDocument.setSpecVersion(Version.CURRENT_SPDX_VERSION);
            spdxDocument.setName("SPDX-" + root.getQualifiedName());
            spdxDocument.setDataLicense(LicenseInfoFactory.parseSPDXLicenseString("CC0-1.0", store, uri, copyManager));
            spdxDocument.setComment("This SPDX document was generated by Dependency-Crawler-1.0");
            spdxDocument.getExternalDocumentRefs();
            spdxDocument.getAnnotations();
            spdxDocument.getDocumentDescribes().add(buildSPDXElement(root));
        } catch (InvalidSPDXAnalysisException | SPDXBuilderException e) {
            logger.error("Error building SPDX document" + e.getMessage());
        }
    }

    private SpdxElement buildSPDXElement(Component component) throws SPDXBuilderException {
        if (buildSPDXElements.containsKey(component.getQualifiedName())) {
            return buildSPDXElements.get(component.getQualifiedName());
        }

        try {
            var spdxPackage = new SpdxPackage(store, uri, SpdxConstants.SPDX_ELEMENT_REF_PRENUM + component.getQualifiedName(), copyManager, true);
            buildSPDXElements.put(component.getQualifiedName(), spdxPackage);

            if (component.getAllHashes() != null) {

                for (Hash hash : component.getAllHashes()) {
                    try {

                        var checksum = spdxPackage.createChecksum(switch (hash.getAlgorithm()) {
                            case "sha1", "HASH_ALG_SHA_1" -> ChecksumAlgorithm.SHA1;
                            case "sha256", "HASH_ALG_SHA_256" -> ChecksumAlgorithm.SHA256;
                            case "sha512", "HASH_ALG_SHA_512" -> ChecksumAlgorithm.SHA512;
                            case "md5", "HASH_ALG_MD_5" -> ChecksumAlgorithm.MD5;
                            default -> throw new SPDXBuilderException("Unexpected value: " + hash.getAlgorithm());
                        }, hash.getValue());
                        spdxPackage.addChecksum(checksum);


                    } catch (Exception e) {
                        logger.error(hash.getValue() + " " + component + " " + e.getMessage());
                    }
                }
            }

//            spdxPackage.setBuiltDate();
            spdxPackage.setName(component.getGroup() != null ? component.getGroup().replace('.', ' ') : " " + component.getArtifactId());
            var supplier = component.getSupplier();
            if (supplier != null) {
                spdxPackage.setSupplier("Organization: " + supplier.getName());
                spdxPackage.setOriginator("Organization: " + supplier.getName());
            }

            if (component.getAllExternalReferences() != null)
                for (ExternalReference externalReference : component.getAllExternalReferences()) {
                    var ref = spdxPackage.createExternalRef(ReferenceCategory.OTHER, new ReferenceType(externalReference.getType()), externalReference.getUrl(), null);
                    spdxPackage.addExternalRef(ref);

                }
            spdxPackage.setPackageFileName(component.getPurl());
            spdxPackage.setDownloadLocation(component.getDownloadLocation() + ".jar");
//            spdxPackage.setFilesAnalyzed();
            if (component.getAllLicenses() != null) {
                buildAllLicenses(component.getAllLicenses(), spdxPackage);
            }
//            spdxPackage.setPackageVerificationCode();
            spdxPackage.setPrimaryPurpose(Purpose.LIBRARY);
//            spdxPackage.setReleaseDate();
//            spdxPackage.setSourceInfo();
//            spdxPackage.setSummary();
//            spdxPackage.setValidUntilDate();
            spdxPackage.setRelationships(buildAllDependencies(component));
            spdxPackage.setVersionInfo(component.getVersion().version());
            Optional.ofNullable(component.getPurl()).ifPresent(purl -> {
                try {
                    spdxPackage.addExternalRef(spdxPackage.createExternalRef(ReferenceCategory.OTHER, new ReferenceType("purl"), purl, null));
                } catch (InvalidSPDXAnalysisException e) {
                    logger.error("Could not set purl for " + component.getQualifiedName() + ". ", e);
                }
            });
//            spdxPackage.getFiles();

            return spdxPackage;
        } catch (InvalidSPDXAnalysisException e) {
            throw new SPDXBuilderException(e.getMessage() + Arrays.toString(e.getStackTrace()));
        }
    }

    private Collection<Relationship> buildAllDependencies(Component component) {
        var list = new ArrayList<Relationship>();

        for (var dependencyComponent : component.getDependenciesFiltered().stream().map(Dependency::getComponent).filter(Objects::nonNull).toList()) {
            try {
                var newRel = new Relationship(store, uri, UUID.randomUUID().toString(), copyManager, true)
                        .setRelationshipType(RelationshipType.DEPENDS_ON)
                        .setRelatedSpdxElement(buildSPDXElement(dependencyComponent));

                list.add(newRel);
            } catch (InvalidSPDXAnalysisException | SPDXBuilderException e) {
                throw new RuntimeException(e);
            }
        }

        return list;


    }

    private void buildAllLicenses(List<LicenseChoice> allLicenses, SpdxPackage spdxPackage) {
        for (LicenseChoice licenseChoice : allLicenses) {
            try {
                var license = LicenseInfoFactory.parseSPDXLicenseString(licenseChoice.getLicense().getId(), store, uri, copyManager);
                spdxPackage.setLicenseDeclared(license);
            } catch (InvalidSPDXAnalysisException e) {
                logger.info("Could not build license  " + licenseChoice.getLicense() + ". " + e.getMessage());
            }
        }
    }


    @Override
    public void rebuildDocument(Pair<SpdxDocument, Component> data, String outputFileName) {
        var component = data.second();
        spdxDocument = data.first();

        var start = System.currentTimeMillis();
        logger.appendInfo("Rewriting SPDX...");

        var outputFileDir = outputFileName.split("/", 2);
        if (outputFileDir.length > 1) {
            //create out dir if not exists
            File outDir = new File(outputFileDir[0]);
            if (!outDir.exists()) {
                if (!outDir.mkdirs()) {
                    logger.error("Could not create output folder for SPDX file: " + outDir.getAbsoluteFile());
                    throw new IllegalStateException();
                }
            }
        }

        // spdx json
        try (var out = new FileOutputStream(outputFileName + ".spdx.json")) {
            updateSpdxDocument(spdxDocument, component);
            Objects.requireNonNull(spdxDocument.getCreationInfo()).setComment("Updated: " + new SimpleDateFormat(SpdxConstants.SPDX_DATE_FORMAT).format(new Date()) + " by Dependency-Crawler-1.0");

            new MultiFormatStore(spdxDocument.getModelStore(), MultiFormatStore.Format.JSON_PRETTY, MultiFormatStore.Verbose.FULL).serialize(spdxDocument.getDocumentUri(), out);

            logger.success(new File(outputFileName).getAbsolutePath() + ".spdx.json saved (" + (System.currentTimeMillis() - start) + "ms)");
        } catch (Exception e) {
            logger.error("Error building SPDX document", e);
        }
    }

    private void updateSpdxDocument(SpdxDocument spdxDocument, Component component) throws InvalidSPDXAnalysisException {
        var componentsToBuild = new ArrayDeque<>(spdxDocument.getDocumentDescribes());
        var buildComponents = new ArrayList<SpdxElement>();
        var loadedComponents = new HashMap<String, Component>();
        for (var c : component.getDependencyComponentsFlatFiltered()) {
            loadedComponents.put(c.getQualifiedName(), c);
        }
        var newComponents = new ArrayList<Component>();


        while (!componentsToBuild.isEmpty()) {
            var spdxPackage = (SpdxPackage) componentsToBuild.poll();
            buildComponents.add(spdxPackage);

            //update the spdx from the component
            Optional.ofNullable(component.getAllLicenses()).ifPresent(licenseChoices -> {
                if (licenseChoices.isEmpty()) return;
                var licenseChoice = licenseChoices.getFirst();
                try {
                    spdxPackage.setLicenseDeclared(LicenseInfoFactory.parseSPDXLicenseString(licenseChoice.getLicense().getId(), spdxDocument.getModelStore(), spdxDocument.getDocumentUri(), spdxDocument.getCopyManager()));
                } catch (InvalidSPDXAnalysisException e) {
                    logger.error("Could not build license  " + licenseChoice.getLicense() + ". " + e.getMessage());
                }
            });
            Optional.ofNullable(component.getSupplier()).ifPresent(manufacturer -> {
                try {
                    spdxPackage.setSupplier("Organization: " + manufacturer.getName());
                } catch (InvalidSPDXAnalysisException e) {
                    logger.error("Could not set supplier for " + component.getQualifiedName() + ". " + e.getMessage());
                }
            });
            Optional.ofNullable(component.getDownloadLocation()).ifPresent(downloadLocation -> {
                try {
                    spdxPackage.setDownloadLocation(downloadLocation + ".jar");
                } catch (InvalidSPDXAnalysisException e) {
                    logger.error("Could not set download location for " + component.getQualifiedName() + ". " + e.getMessage());
                }
            });
            Optional.ofNullable(component.getAllHashes()).ifPresent(hashes -> {
                List<Checksum> oldChecksums = new ArrayList<>();
                try {
                    oldChecksums.addAll(spdxPackage.getChecksums());
                    spdxPackage.getChecksums().clear();
                } catch (InvalidSPDXAnalysisException e) {
                    logger.error("Could not clear checksums for " + component.getQualifiedName() + ". " + e.getMessage());
                }
                for (Hash hash : hashes) {
                    try {
                        var checksum = spdxPackage.createChecksum(switch (hash.getAlgorithm()) {
                            case "SHA1", "HASH_ALG_SHA_1" -> ChecksumAlgorithm.SHA1;
                            case "SHA256", "HASH_ALG_SHA_256" -> ChecksumAlgorithm.SHA256;
                            case "SHA512", "HASH_ALG_SHA_512" -> ChecksumAlgorithm.SHA512;
                            case "MD5", "HASH_ALG_MD_5" -> ChecksumAlgorithm.MD5;
                            default -> throw new SPDXBuilderException("Unexpected value: " + hash.getAlgorithm());
                        }, hash.getValue());
                        oldChecksums.removeIf(it -> {
                            try {
                                return it.getAlgorithm().equals(checksum.getAlgorithm());
                            } catch (InvalidSPDXAnalysisException e) {
                                throw new RuntimeException(e);
                            }
                        });
                        spdxPackage.addChecksum(checksum);
                    } catch (Exception e) {
                        logger.error("Error creating hash for " + component + " ", e);
                    }
                }
                for (Checksum oldChecksum : oldChecksums) {
                    try {
                        spdxPackage.addChecksum(oldChecksum);
                    } catch (InvalidSPDXAnalysisException e) {
                        logger.error("Could not add checksum for " + component.getQualifiedName() + ". " + e.getMessage());
                    }
                }
            });
            Optional.ofNullable(component.getAllExternalReferences()).ifPresent(externalReferences -> {
                for (ExternalReference externalReference : externalReferences) {
                    try {
                        ExternalRef ref = spdxPackage.createExternalRef(ReferenceCategory.OTHER, new ReferenceType(externalReference.getType()), externalReference.getUrl(), null);
                        spdxPackage.addExternalRef(ref);
                    } catch (InvalidSPDXAnalysisException e) {
                        logger.error("Could not set external reference for " + component.getQualifiedName() + ". ", e);
                    }
                }
            });
            Optional.ofNullable(component.getPurl()).ifPresent(purl -> {
                try {
                    spdxPackage.addExternalRef(spdxPackage.createExternalRef(ReferenceCategory.OTHER, new ReferenceType("purl"), purl, null));
                } catch (InvalidSPDXAnalysisException e) {
                    logger.error("Could not set purl for " + component.getQualifiedName() + ". ", e);
                }
            });


            //relationship of the element
            for (var relationship : spdxPackage.getRelationships()) {
                if (relationship.getRelationshipType().toString().equals("DEPENDS_ON")) {
                    var relationElement = relationship.getRelatedSpdxElement().get();
                    var relationComponent = loadedComponents.get(relationElement.getId());
                    if (relationComponent == null) {
                        relationElement.removeRelationship(relationship);
                        continue;
                    }
                    if (buildComponents.contains(relationElement)) continue;
                    componentsToBuild.add(relationElement);
                }
            }
        }
    }
}
