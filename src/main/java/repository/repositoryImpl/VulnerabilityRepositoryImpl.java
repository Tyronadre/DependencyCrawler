package repository.repositoryImpl;

import com.google.gson.JsonParser;
import data.Component;
import data.Vulnerability;
import data.internalData.OSVVulnerability;
import logger.Logger;
import repository.VulnerabilityRepository;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.ArrayList;
import java.util.List;

public class VulnerabilityRepositoryImpl implements VulnerabilityRepository {
    private static final Logger logger = Logger.of("Vul_Service");

    String baseUrl = "https://api.osv.dev/v1/query";
    List<Vulnerability> readVulnerabilities = new ArrayList<>();
    HttpClient client = HttpClient.newHttpClient();

    static VulnerabilityRepositoryImpl instance = new VulnerabilityRepositoryImpl();

    private VulnerabilityRepositoryImpl() {

    }

    public static VulnerabilityRepositoryImpl getInstance() {
        return instance;
    }

    @Override
    public List<Vulnerability> getVulnerabilities(Component component) {
        var start = System.currentTimeMillis();
        var vulnerabilities = new ArrayList<Vulnerability>();

        StringBuilder body = new StringBuilder();
        body.append("{\"version\": \"")
                .append(component.getVersion().version())
                .append("\", \"package\": {\"name\": \"")
                .append(component.getGroup())
                .append(":")
                .append(component.getArtifactId())
                .append("\", \"ecosystem\": \"Maven\"}}");
        try {
            var httpRequest = client.send(HttpRequest.newBuilder()
                            .uri(URI.create(baseUrl))
                            .POST(HttpRequest.BodyPublishers.ofString(body.toString()))
                            .build()
                    , HttpResponse.BodyHandlers.ofString());

            if (httpRequest.statusCode() == 200) {
                var vulnerabilityData = JsonParser.parseString(httpRequest.body()).getAsJsonObject();
                if (vulnerabilityData.has("vulns"))
                    for (var vulnerability : vulnerabilityData.get("vulns").getAsJsonArray())
                        vulnerabilities.add(new OSVVulnerability(component, vulnerability.getAsJsonObject()));
            } else {
                throw new RuntimeException("Failed to get vulnerabilities from " + component.getQualifiedName() + ". Response code: " + httpRequest.statusCode());
            }
//            HttpURLConnection connection = (HttpURLConnection) URI.create(baseUrl).toURL().openConnection();
//            connection.setDoOutput(true);
//            connection.setRequestMethod("POST");
//            connection.setRequestProperty("Content-Type", "application/json");
//
//            connection.setRequestProperty("Content-Length", String.valueOf(body.length()));
//            connection.getOutputStream().write(body.toString().getBytes());
//            connection.getOutputStream().flush();
//
//            connection.disconnect();
//
//            int responseCode = connection.getResponseCode();
//            if (responseCode == HttpURLConnection.HTTP_OK) {
//                var inputStream = connection.getInputStream();
//                var vulnerabilityData = JsonParser.parseReader(new InputStreamReader(inputStream)).getAsJsonObject();
//                if (vulnerabilityData.has("vulns"))
//                    for (var vulnerability : vulnerabilityData.get("vulns").getAsJsonArray())
//                        vulnerabilities.add(new OSVVulnerability(component, vulnerability.getAsJsonObject()));
//            }


        } catch (Exception e) {
            logger.error("Failed to get vulnerabilities from" + component.getQualifiedName() + ". (" + (System.currentTimeMillis() - start) + " ms)", e);
        }

        if (vulnerabilities.isEmpty()) {
            logger.info("No vulnerabilities found for " + component.getQualifiedName() + " (" + (System.currentTimeMillis() - start) + " ms)");
        } else {
            logger.info("Found " + vulnerabilities.size() + " vulnerabilities for " + component.getQualifiedName() + " (" + (System.currentTimeMillis() - start) + " ms)");
        }

        return vulnerabilities;
    }

    @Override
    public void updateVulnerabilities(Component component) {
        var vulComponent = new ArrayList<>(component.getAllVulnerabilities());
        var vulLoaded = getVulnerabilities(component);

        var vulComponentToDelete = vulComponent.stream().filter(vulComp -> vulLoaded.stream().anyMatch(vulNet -> vulComp.getId().equals(vulNet.getId()))).toList();
        var vulLoadedToAdd = vulLoaded.stream().filter(vulNet -> vulComponent.stream().noneMatch(vulComp -> vulComp.getId().equals(vulNet.getId()))).toList();

        vulComponentToDelete.forEach(component::removeVulnerability);
        vulLoadedToAdd.forEach(component::addVulnerability);
    }

    @Override
    public void addReadVulnerability(Vulnerability vulnerability) {
        this.readVulnerabilities.add(vulnerability);
    }

    @Override
    public List<Vulnerability> getReadVulnerabilities() {
        return readVulnerabilities;
    }
}
